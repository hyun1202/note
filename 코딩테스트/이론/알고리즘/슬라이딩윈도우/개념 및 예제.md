
슬라이딩 윈도우 관련 문제
	[[DNA 비밀번호]]
	[[최솟값 찾기]]

### 슬라이딩 윈도우

윈도우(특정범위)가 있을 때, 윈도우 내부 요소의 값을 이용하여 문제를 풀이하는 알고리즘
* 배열이나 문자열같은 선형구조에서 요소의 **일정 범위값을 비교** (고정적)할 때 사용
* 투 포인터 패턴과 유사
* 특정한 조건에 따라 window가 커지거나 닫히거나, 새로 생성될 수도 있음
* **한번 구한 값을 버리지 않고 재사용한다.**
* **교집합의 정보를 공유하고, 차이가 나는 양쪽 끝 원소만 갱신하는 방법**을 통해 **배열이나 리스트의 요소의 일정 범위의 값을 비교**할 때 사용하면 매우 유용
![[Pasted image 20240828124501.png]]

ex) 한 단어의 문자들 중 연속된 고유 문자의 길이가 가장 긴 부분 출력

#### 예제

[1, 3, 2, 6, -1, 4, 1, 8, 2] 에서 연속적인 5개의 숫자의 합의 최대값을 구하여라

```
[1, 3, 2, 6, -1], 4, 1, 8, 2  // 11
1, [3, 2, 6, -1, 4], 1, 8, 2  // 14
1, 3, [2, 6, -1, 4, 1], 8, 2  // 12
1, 3, 2, [6, -1, 4, 1, 8], 2  // 18
1, 3, 2, 6, [-1, 4, 1, 8, 2]  // 14
```

첫번째로 1+3+2+6-1을 계산하고 두번째로 3+2+6-1+4를 계산하는데 **중복적인 부분이 생긴다**
그럼 그 중복적인 경우를 코드로 구현하고, 처음 계산된 합에서 **맨 앞 인덱스를 빼고, 마지막 인덱스를 더하여 계산을 하면 되지 않을까?**

첫번째로 모든 수 계산 = 1 + 3 + 2 + 6 -1 = 11
두번째 수 계산 = 11 - 1 + 4 = 14
세번째 수 계산 = 14 - 3 + 1 = 12
네번째 수 계산 = 12 - 2 + 8 = 18
다섯번째 수 계산 = 18 - 6 + 2 = 14

#### java 코드
```java
int k = 5;  
int[] a = new int[] {1, 3, 2, 6, -1, 4, 1, 8, 2};  
int N = a.length;  
  
// 초기화  
int sum = 0;  
int result = 0;  
  
for (int i=0; i<k; i++) {  
    sum += a[i];  
}  
  
result = sum;  
  
// 슬라이딩 윈도우 알고리즘 시작  

for (int i = k; i < N; i++) {  
    // i=k, 즉 5일 때, i=5 a[5] - a[0] 
    // =>  11 + 4 - 1 = 14   => 3 + 2 + 6 -1 + 4의 효과를 낸 것  
    sum += a[i] - a[i - k];  
    if (result < sum) {  
        result = sum;  
    }  
}  
  
System.out.println("result = " + result);
```

위 코드에서 중요한 부분은 for문의 조건문과 sum을 구하는 곳이다.

1. `int i = k; i < N; i++`
	* k=슬라이드 윈도우 크기, N= 배열의 크기
	* 슬라이드 윈도우만큼 반복해야하므로 배열의 크기 - 슬라이드 윈도우의 크기를 해주어 총 반복해야하는 횟수를 구한다.
2.  `sum += a[i] - a[i - k];`
	* `a[i - k]`: 윈도우 크기에 벗어남으로 써, 해당하는 값을 빼주어야 한다.
	* `a[i]`: 윈도우에 들어왔으므로 해당하는 값을 더해주어야 한다.