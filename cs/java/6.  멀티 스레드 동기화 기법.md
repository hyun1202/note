# Synchronized
동기화 프로그래밍을 언어의 문법에 포함하여 제공

## 장점
* 편리한 사용
* 자동 잠금 해제
	* 동기화 메서드나 블록이 완료되면 자동으로 락 대기 중인 다른 스레드의 잠금이 해제됨

## 단점
* 제공하는 기능이 너무 단순하다.
* 무한대기
	* `BLOCK` 상태의 스레드는 락이 풀릴 때 까지 대기함
	* 타임아웃이 없음
	* 중간에 인터럽트도 X
* 공정성: 어떤 스레드가 락을 획득할 지 알 수 없음
	* 최악의 경우 특정 스레드가 너무 오랜기간 락을 획득하지 못할 수 있음

# 임계영역?
* 둘 이상의 스레드가 동시에 접근해서는 안되는 **공유자원을 접근하는 코드**의 일부

# LockSupport
* 무한 대기 문제 해결
* 스레드를 `WAITING` 상태로 변경 
	CPU의 스케줄링에 들어가지 않는다.

## 기능
* `park()`: 스레드를 `WAITING` 상태로 변경
* `parkNanos(nanos)`: 스레드를 나노 초 동안만 TIME_WAITING 상태로 변경한다.
	* 지정한 나노 초가 지나면 `RUNNABLE` 상태로 변경
	* `unpark(thread)`: `WAITING` 상태의 대상 스레드를 `RUNNABLE` 상태로 변경

## 한계
* LockSupport는 저수준의 기능이므로 활용해서 안전한 임계 영역을 만드는 추가적인 기능을 개발해야 한다.

# ReentrantLock
* `synchronized`와 `BLOCKED` 상태를 통한 임계 영역 관리의 한계를 극복 
	`synchronized`의 단점
	 * 무한 대기: `BLOCKED` 상태의 스레드는 락이 풀릴 때 까지 무한 대기
	 * 공정성: 특정 스레드가 오랜기간 락을 획득하지 못할 수 있음

## Lock 인터페이스
* `Lock` 인터페이스는 동시성 프로그래밍에서 쓰이는 안전한 임계 영역을 위한 락을 구현하는데에 사용
* `void lock()`
  락 획득, 락이 풀릴 때 까지 `WAITING`
  인터럽트가 발생해도 **무시**하고 락을 기다린다.
	  순간 대기 상태를 빠져나오지만, 메서드에서 다시 `WAITING`상태로 강제로 변경한다.
* `void lockInterruptibly()`
  락 획득 시도, 락을 획득할 때까지 대기하나 인터럽트가 발생하면 락 획득 포기
* `boolean tryLock()`
  락 획득 시도, 즉시 성공 여부 반환
* `boolean tryLock(long time, TimeUnit unit)`
  주어진 시간동안 락 획득 시도, 락을 획득하면 true, 못하면 false
  인터럽트가 발생하면 락 획득 포기
* `void unlock()`
  락 해제, 락을 획득한 스레드가 호출해야 함(아닐 경우 예외)
* `Condition newCondition()`
  `Condition`객체를 생성하여 반환
  스레드가 특정 조건을 기다리거나 신호를 받을 수 있도록 함
  `Object`클래스의 `wait`, `notify`, `notifyAll` 메서드와 유사한 역할

## 공정성 문제
* 락을 반납했을 때 어떤 스레드가 락을 획득할지 알 수 없어, 최악의 경우 특정 스레드가 오랜기간 락을 획득하지 못할 수도 있다.
* `Lock` 인터페이스의 구현체인 `ReentrantLock`에서 공정하게 락을 얻을 수 있는 모드를 제공함
```java
// 공정 모드
new ReentrantLock(true);
// 비공정 모드
new ReentrantLock();
```

### 비공정 모드
* 성능 우선: 락을 획득하는 속도가 빠르다.
* 선점 가능: 새로운 스레드가 기존 대기 스레드보다 먼저 락 획득 가능
* 기아 현상 가능성: 특정 스레드가 계속해서 락을 획득하지 못한다.

### 공정 모드
* 공정성 보장: 대기 큐에서 먼저 대기한 스레드가 락을 먼저 획득
* 기아 현상 방지: 모든 스레드가 언젠가 락을 획득할 수 있게 보장
* 성능 저하: 락을 획득하는 속도가 느려질 수 있음

비공정 모드는 성능 중시로 락을 빨리 획득할 수 있지만, 기아 현상 가능
공정 모드는 공정성을 중시하지만, 성능 저하될 수 있음


