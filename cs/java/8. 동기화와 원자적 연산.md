# 원자적 연산
* 해당 연산이 더 이상 나눌 수 없는 단위로 수행됨
* 중단되지 않고, 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 성질
* 멀티스레드 상황에서 **다른 스레드의 간섭 없이 안전하게 처리**되는 연산

예시
`volatile int i = 0;`과 같은 필드가 있을 때
* 원자적 연산: `i = 1;`
	* 단 하나의 순서로 실행이 되기 때문
	* 오른쪽에 있는 1의 값을 왼쪽의 `i`변수에 대입
* 비원자적 연산: `i = i + 1;` (`i++`)
	* 오른쪽에 있는 `i`의 값을 읽는다. `i`의 값은 10
	* 읽은 10에 1을 더해 11을 만든다.
	* 더한 11을 왼쪽의 `i`변수에 대입

원자적 연산은 멀티스레드 상황에서 아무런 문제가 발생하지 않는다.
하지만 비원자적 연산일 경우 `synchronized`블럭이나 `Lock`을 사용해서 **안전한 임계 영역**을 만들어야 한다.

## AtomicInteger
* 멀티스레드 상황에서 안전하게 증가, 감소 연산을 수행할 수 있다.
* **락을 사용하지 않고 원자적 연산을 만들어낸다.**
* `Integer`, `Long`, `Boolean`등 다양한 `AtomicXxx` 클래스가 존재한다.

성능 테스트
```
BasicInteger: ms=4
VolatileInteger: ms=177
SyncInteger: ms=329
MyAtomicInteger: ms=186
```

* BasicInteger: `private int value;`
	* 가장 빠르다.
	* 안전한 임계 영역, `volatile`모두 사용하지 않으므로 멀티스레드 상황에선 사용 불가
* VolatileInteger: `volatile private int value;`
	* CPU 캐시를 사용하지 않고 메인 메모리 사용, 멀티스레드 상황에선 사용 불가
* SyncInteger: `public synchronized void increment()`
	* syncronized를 사용한 안전한 임계 영역이 있으므로 멀티스레드 상황에서 사용 가능
	* **Atomic보다 성능이 낮음**
* AtomicInteger: `AtomicInteger atomicInteger = new AtomicInteger(0);`
	* 자바에서 제공하는 AtomicInteger 사용, 멀티 스레드 상황에서 사용 가능  
	* 성능도 synchornized, lock을 사용하는 경우보다 1.5 ~ 2배정도 빠름

## CAS 연산
* 락을 걸지 않고 원자적인 연산을 수행 (lock-free)
* Compare-And-Swap, Compare-And-Set 연산이라 한다.
* 락을 완전히 대체할 순 없고, **작은 단위의 일부 영역에 적용**할 수 있다.

락 기반 방식의 문제
* **락 기반 방식**에서는 락이 해제될 때까지 대기해야 한다. 획득하고 반납하는 과정이 계속 반복되므로 직관적이지만 **상대적으로 무거운 방식이다.**

### compareAndSet(0, 1)
* `atomicInteger`가 가지고 있는 값이 현재 0이면 이 값을 1로 변경하라는 매우 간단한 메서드이다.
* 이 메서드는 **원자적으로 실행**된다
* `CAS`연산은 메모리에 있는 값이 기대하는 값이라면 원하는 값으로 변경한다.

**CPU 하드웨어의 지원**
CAS연산은 이렇게 원자적이지 않은 두 개의 연산을 CPU 하드웨어 차원에서 특별하게 하나의 원자적인 연산으로 묶어서 제공한다.

CAS
1. CAS(x001, 0, 1)
2. cpu는 x001을 확인하고 x001의 값을 변경하지 못하게 막는다.
3. CAS연산으로 값을 성공적으로 변경하고 나면 `true` 또는 `false` 를 반환한다.

**incrementAndGet()**
```java
private static int incrementAndGet(AtomicInteger atomicInteger) {  
        int getValue;  
        boolean result;  
        do {  
            getValue = atomicInteger.get();  
            log("getValue: " + getValue);  
            // cas 연산 이용  
            result = atomicInteger.compareAndSet(getValue, getValue + 1);  
            log("result: " + result);  
        } while (!result);  // 실패하면 다시 실행  
        return getValue + 1;  
    }
```
락을 사용하지 않고, 다른 스레드가 값을 먼저 증가해서 문제가 발생하는 경우 **루프를 돌며 재시도**

### 결론
락을 획득하기 위해 대기하지 않으므로 대기 시간과 오버헤드가 줄어든다.
하지만 **충돌이 빈번하게 발생하는 환경에서는 자주 실패하고 재시도해야 하므로 성능 저하가 발생할 수 있다.**(CPU 자원 소모)
즉, 연산이 길지 않고 매우 짧게 끝날 때 사용해야한다.

## CAS(Compare-And-Swap) VS Lock
* 락 방식
	* 비관적 접근
	* 데이터에 접근하기 전 항상 락 획득
* CAS 방식
	* 낙관적 접근
	* 락을 사용하지 않고 데이터에 바로 접근
	* 충돌 발생 시 그때 재시도

## 스핀 락
* 락을 획득하기 위해 자원을 소모하면서 반복적으로 확인(스핀)하는 락 메커니즘
* CAS를 사용해서 구현할 수 있다.