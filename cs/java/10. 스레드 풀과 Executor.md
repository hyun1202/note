# 스레드를 직접 사용할 때의 문제점
1. 스레드 생성 시간으로 인한 성능 문제
	* 메모리 할당: 각 스레드는 자신만의 스택을 가지고 있어야 한다.
	* 운영체제 자원 사용: 운영체제 커널 수준에서 이루어지며 시스템 콜을 통해 처리된다. 이는 CPU와 메모리 리소스를 소모하는 작업이다.
	* 운영체제 스케줄러 설정: 스레드가 생성되면 운영체제의 스케줄러는 이 스레드를 관리하고 실행 순서를 조정해야 한다.
	* 스레드 하나는 보통 1MB 이상의 메모리를 사용
2. 스레드 관리 문제
	* CPU, 메모리 자원은 한정되어 있기 때문에 최대 스레드 수 까지만 생성되도록 스레드를 관리해야 한다.
	* **즉 어딘가에 관리가 되어 있어야한다.**
3. `Runnable` 인터페이스의 불편함
	* 스레드의 실행 결과를 받을 수 없다.
	* 체크 예외를 던질 수 없다.

스레드 생성 작업은 상대적으로 무거우므로 **미리 생성하고 생성한 스레드를 재사용하는 방법**을 고려할 수 있다.
	처음 생성할 때를 제외하고는 생성을 위한 시간이 들지 않는다.

## 스레드 풀
* 1번, 2번 문제를 해결하기 위해 **생성하고 관리하는 스레드 풀이 필요**하다.
* 컬렉션에 스레드를 보관하고 재사용할 수 있게 하면 된다.
* **처리할 작업이 없다면 대기(`WAITING`)하고 작업 요청이 오면 실행(`RUNNABLE`) 상태로 변경**한다.
* 하지만 생산자 소비자 문제까지 겹친다.

## Executor 프레임워크
* 생산자 소비자 문제, 스레드 생성, 관리 등을 모두 해결해주는 도구이다.
* 멀티스레딩 및 병렬 처리를 쉽게 사용할 수 있도록 돕는 기능의 모음
* 요청 스레드가 결과를 받아야 하는 상황이면 **`Callable`을 사용하여 받을 수 있다.**

### Callable
* `Runnable`은 체크 예외를 던질 수 없다.
* `java.util.concurrent`에서 제공되는 기능이다.
* `call()`은 반환 타입이 제네릭`V`이다.
* `throws Exception`이므로 체크 예외도 던질 수 있다.
```java
ExecutorService es = Executors.newFixedThreadPool(1);  
// submit()을 이용하여 Callable 작업을 전달할 수 있다.  
Future<Integer> future = es.submit(new MyCallable()); 
Integer result = future.get();  
log("result value = " + result);  
es.close();
```
### Future
* 다른 스레드가 메서드를 실행해서 **즉시 결과를 받는 것은 불가능**하다.
* 이런 이유로 결과를 나중에 받을 수 있는 `Future`라는 객체를 대신 제공한다.
* `Future` 객체 안에 실행 객체의 인스턴스를 보관하고 내부에 작업의 완료 여부와 결과 값을 가진다.
* `Future`의 구현체인 `FutureTask`는 `Runnable` 인터페이스도 함께 구현한다.

#### 작동 방식
1. taskA 작업을 완료한다.
2. `Future`에 반환 값을 담는다.
3. `Future`의 작업 완료 상태를 변경한다.
4. 요청 스레드를 깨운다.

#### Future 없이 바로 반환이 된다면?
```java
// 아래 예제는 없는 문법이다.
Integer result1 = es.submit(task1);
Integer result2 = es.submit(task2);
```
task1 완료 이후 task2가 실행이 된다.

-> Future는 스레드를 먼저 실행하고, 그 이후에 값을 받아올 수 있는 것이다.

#### Future 잘못된 사용법
```java
Future<Integer> f1 = es.submit(task1); // 2초
Integer result1 = f1.get();

Future<Integer> f2 = es.submit(task2); // 2초
Integer result2 = f2.get();
```

`Future`을 사용하지 않은 것과 동일하다.

```
16:31:35.100 [pool-1-thread-1] 작업 시작
16:31:37.123 [pool-1-thread-1] 작업 완료 result=1275  # 2초
16:31:37.125 [pool-1-thread-2] 작업 시작
16:31:39.130 [pool-1-thread-2] 작업 완료 result=3775  # 2초
16:31:39.133 [     main] task1.result= 1275
16:31:39.134 [     main] task2.result= 3775
16:31:39.135 [     main] task1 + task2 = 5050
16:31:39.135 [     main] End
```

즉, 2초씩 소요되어 총 4초의 시간이 걸린 것을 볼 수 있다.

#### 올바른 Future 사용법
* 작업을 모두 `submit()` 하고 그 다음에 `future.get()`을 이용하여 값을 가져온다.

### 정리
* 결과를 받을 때 까지 요청 스레드는 아무 일도 못하고 대기해야 한다.
* `Future` 개념 덕분에 대기하지 않고 다른 작업을 수행할 수 있다.
* 요청 스레드를 블로킹 상태로 만들지 않고 필요한 요청을 모두 수행할 수 있게 해준다.

## ExecutorService
* 여러 작업을 한 번에 편리하게 처리하는 `invokeAll()`, `invokeAny()` 기능 제공

* `void execute(Runnable command)`: `Runnable` 작업 제출, 반환 값이 없다.
* `<T> Future<T> submit(Callable<T> task)`: `Callable` 작업을 제출하고 결과를 반환받는다.
* `Future<?> submit(Runnable task)`: `Runnable` 작업을 제출하고 결과를 반환 받는다.
	* `Runnable은` 반환 결과가 없지만 작업 완료 여부를 확인하기 위해 사용
* `invokeAll(Collection<? extends Callable<T>> tasks)`: 모든 `Callable` 작업을 제출하고, 모든 작업이 완료될 때까지 기다린다.
* `invokeAny(Collection<? extends Callable<T>> tasks)``: 하나의 `Callable`작업이 완료될 때까지 기다리고, 가장 먼저 완료된 작업의 결과를 반환
  완료되지 않은 나머지 작업은 취소한다.

# 인사이트
여태까지 `Future`나 `Promise`를 이용하여 `await(node)`이나 `future.get(java)`을 사용했을 때, 비동기라고는 하지만 결국엔 동기적인 방식으로 작동했기에 이것이 비동기가 맞는가? 라는 것에 대한 의문이 있었다.

하지만 결론적으로 헷갈렸던 것은 비동기 방식과 논블로킹이었다.
비동기적으로 실행시키기 위해 다른 스레드를 이용한 것이지만, 결국 값을 받기 위해 메인 스레드는 `BLOCKED`가 되어야 했던 것이다. 결국 **`get()`을 이용한 방식은 블로킹 방식**이 되는 것이다.
하지만 해당 메서드가 실행될 때는 **비동기 방식**으로 처리가 된다.
즉, 비동기 방식이나 블로킹 방식인 것이다.
`future.get()`를 사용하지 않는 것은, 비동기 방식이나 논 블로킹 방식인 것이다.

하지만, await()는 node기반의 싱글 스레드로 동작하여 메인 스레드는 차단되지 않는다.

즉, 비동기, 동기는 실행 방식의 문제이고 
블로킹, 논블로킹의 차이는 스레드 상태의 문제이다.