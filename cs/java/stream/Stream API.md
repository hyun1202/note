# Stream API
- 자바 8부터 추가된 기능
- 컬렉션이나 배열에 저장된 요소들을 반복문 없이도 간단하게 필터링, 변환, 정렬 등의 작업 가능
- 데이터 처리에 있어 간결하고 효율적인 코드 작성 가능
- 중간 연산과 최종 연산을 구분하며, 지연 연산을 통해 불필요한 연산 최소화
	- 내부적으로 파이프라인 형태를 만들어 데이터를 단계별로 처리

## 지연 연산
* filter, map같은 중간 연산들은 `toList`와 같은 최종 연산이 호출되기 전까지 실행되지 않는다.
* 중간 연산은 람다 함수만 내부에 저장해두고, 해당 함수를 실행하지 않는다.
* 최종 연산이 실행되는 순간 그때서야 순차적으로 저장해둔 람다들이 수행한다.
	* 최종 연산은 `toList()`, `forEach()`, `findFirst()`등이 있다.

### 장점
* 단축 평가 (불필요한 연산의 생략)
	* 스트림이 실제로 데이터를 처리하기 직전에 **불필요한 연산을 피할 수 있다.**
	* ex) `findFirst()`, `limit()`
* 메모리 사용 효율
	* 중간 연산 결과를 매 단계마다 별도의 자료구조에 저장하지 않고, 최종 연산 때까지 **필요할 때만 가져와서 처리**
* 파이프라인 최적화
	* 요소를 하나씩 꺼내면서 연산을 묶어서 실행

## 중간 연산

| 연산        | 설명                                     |
| --------- | -------------------------------------- |
| filter    | 조건에 맞는 요소만 남김                          |
| map       | 요소를 다른 형태로 변환                          |
| flatMap   | 중첩 구조 스트림을 일차원으로 평탄화                   |
| distinct  | 중복 요소 제거                               |
| sorted    | 요소 정렬                                  |
| peek      | 중간 처리 (로그, 디버깅)                        |
| limit     | 앞에서 N개의 요소만 추출                         |
| skip      | 앞에서 N개의 요소를 건너뛰고 이후 요소만 추출             |
| takeWhile | 조건을 만족하는 동안 요소 추출 (Java 9+)            |
| dropWhile | 조건을 만족하는 동안 요소를 버리고 이후 요소 추출 (Java 9+) |
## 최종 연산
- 스트림 파이프라인의 끝에 호출되어 실제 연산을 수행하고 결과를 만들어낸다.
- 최종 연산이 실행된 이후 스트림은 소모되어 더 이상 사용할 수 없다.

| 연산                | 설명                                                   |
| ----------------- | ---------------------------------------------------- |
| collect           | Collector를 사용하여 결과 수집                                |
| toList (Java 16+) | 스트림을 불변 리스트로 수집                                      |
| toArray           | 스트림을 배열로 변환                                          |
| forEach           | 각 요소에 대해 동작 수행(반환X)                                  |
| count             | 요소 개수 반환                                             |
| reduce            | 누적 함수를 사용해 모든 요소를 단일 결과로 합침<br>초기값이 없으면 Optional로 반환 |
| min / max         | 최소값, 최대값을 Optional로 반환                               |
| findFirst         | 조건에 맞는 첫 번째 요소 반환(Optional)                          |
| findAny           | 조건에 맞는 아무 요소 반환(Optional)                            |
| anyMatch          | 하나라도 조건을 만족하는지(boolean)                              |
| allMatch          | 모두 조건 만족하는지(boolean)                                 |
| noneMatch         | 하나라도 조건을 만족하지 않는지(boolean)                           |
## 기본형 특화 스트림
- 기본형(primitive) 특화 스트림
- `IntStream`, `LongStream`, `DoubleStream`

| 메서드 / 기능                       | 설명                                   |
| ------------------------------ | ------------------------------------ |
| sum()                          | 모든 요소의 합계를 구한다.                      |
| average()                      | 모든 요소의 평균을 구한다.(OptionalDouble)      |
| summaryStatistics()            | 최소값, 최대값, 합계, 개수, 평균 등이 담긴 객체 반환     |
| mapToLong()<br>mapToDouble()   | 타입 변환<br>ex: IntStream -> LongStream |
| mapToObj()                     | 객체 스트림으로 변환(기본형 -> 참조형)              |
| boxed()                        | 기본형 특화 스트림을 박싱된 객체 스트림으로 변환          |
| sum(), min()<br>max(), count() | 합계, 최소값, 최대값, 개수를 반환<br>(타입별 반환)     |

## 성능 - 전통 반복문 vs 스트림  vs  기본형 특화 스트림
- 실제 성능은 데이터 양, 연산 종류, JVM 최적화 등에 따라 달라진다.
- 일반적인 애플리케이션에서는 거의 차이가 없다 (최소 수천만 건 이상이어야 함)
- 박싱/언박싱을 많이 유발하지 않는 상황이라면 일반 스트림과 기본형 특화 스트림간 성능차이는 그리 크지 않을 수 있다.
- **코드의 가독성과 유지보수성을 위해 스트림API를 사용**하는 것이 보통 더 나은 선택이다.

| 구분         | 속도                                                            |
| ---------- | ------------------------------------------------------------- |
| for        | 가장 빠름                                                         |
| 스트림        | for문에 비해 1.5 ~ 2배정도 느리다<br>박싱/언박싱 오버헤드 발생                     |
| 기본형 특화 스트림 | for문과 거의 비슷하거나 for문이 10~30% 정도 더 빠르다<br>박싱/언박싱 오버헤드를 피할 수 있다. |
