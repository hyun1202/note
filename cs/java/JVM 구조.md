## JVM
자바 가상 머신으로, JVM만 있다면 자바로 작성된 언어를 os와 관계 없이 실행시킬 수 있게 하기 위해 만들어졌다.

### JVM 동작 과정
![[Pasted image 20241021112132.png]]
1. 자바 프로그램 실행 시 OS로부터 메모리를 할당 받는다.
2. 자바 컴파일러 javac가 java파일을 .class로 컴파일 한다.
3. 클래스 로더는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(실질적인 메모리를 할당 받아 관리하는 영역)에 올린다.
4. 런타임 데이터 영역에 로딩 된 바이트 코드는 Execution Engine을 통해 해석된다.
5. 이 과정에서 Execution Engine에 의해 가비지 셀렉터의 작동과 스레드 동기화가 이루어진다.


#### 클래스 로더 (Class Loader)
![[Pasted image 20241021112118.png]]
바이트 코드들을 엮어 JVM의 메모리 영역인 Runtime Data Areas에 배치
* JVM 내로 클래스 파일을 동적으로 로드하고 링크를 통해 배치하는 작업을 수행
* 어플리케이션에서 필요한 경우 동적으로 메모리에 적재


로딩 순서는 Loading -> Linking -> Initalization 으로 구성
1. Loading: 클래스 파일을 가져와 JVM의 메모리에 로드
2. Linking: 클래스 파일을 사용하기 위해 검증
	1. Verifying(검증): 읽어들인 클래스가 JVM 명세에 명시된 대로 구성되어 있는지 검사
	2. preparing(준비): 클래스가 필요로 하는 메모리를 할당
	3. Resolving(분석): 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경
3. Initialization: 클래스 변수들을 적절한 값으로 초기화 (static 필드들을 설정된 값으로 초기화 등)

#### 실행 엔진 (Execution Engine)
* 클래스 로더를 통해 런타임 데이터 영역에 배치된 **바이트 코드를 명령어 단위로 읽어서 실행**
* 바이트 코드는 가상머신(JVM)이 이해할 수 있는 중간 레벨로 컴파일된 코드이므로 **기계어로 변환 필요**
* 이 과정에서 **인터프리터와 JIT 컴파일러** 두 가지 방식을 혼합하여 바이트 코드를 실행
	* 인터프리터: 바이트 코드를 하나씩 읽어서 해석하고 바로 실행(느림)
	* JIT(Just-In-Time) 컴파일러: 바이트 코드 전체를 컴파일 하여 기계어로 변환 
		* 기계어로 변환하는 데에 비용이 소요되므로 모든 코드를 JIT 컴파일러 방식으로 실행하지 않고 **인터프리터 방식으로 실행하다 적절한 시점에 바이트 코드 전체를 컴파일하여 기계어로 변경**

### 가비지 컬렉터 (Garbage Collector, GC) 
[[Garbage Collection(GC)]]
* Heap 메모리 영역에서 더는 사용하지 않는 메모리를 자동으로 회수
* 메모리가 언제 해제되는지 정확하게 알 수 없어 제어하기 힘들다.
* 가비지 컬렉션이 동작하는 동안에는 GC관련 스레드를 제외한 모든 스레드는 멈추게 된다.
	* Stop The World (STW): GC를 수행하기 위해 JVM이 프로그램 실행을 멈추는 현상

### 런타임 데이터 영역 (Runtime Data Area)
![[Pasted image 20241021115009.png]]
* JVM의 메모리 영역으로, 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역
* 영역은 크게 Method Area, Heap Area, Stack Area, Pc Register, Native Method Stack으로 나뉜다.

| 영역                                  | 용도                                                                                                                                      | 특징                                                                        | 스레드 공유 |
| ----------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- | ------ |
| Method<br>(Perm Gen)                | - 일반적인 메모리 구조에서의 **코드 영역과 유사**<br>- JVM에서 읽어들인 클래스와 인터페이스에 대한 런타임 상수 풀, 메서드와 필드, Static 변수, 메서드 바이트 코드 등을 저장                            | - JVM 시작시 생성, 종료되면 사라짐<br>- 공간 부족하면OOM(OutOfMemoryError) 발생               | 모든 스레드 |
| Runtime Constant Pool<br>(런타임 상수 풀) | - 클래스 파일 포맷에서 constant_pool 테이블에 해당<br>- 각 클래스와 인터페이스 상수, 메서드와 필드에 대한 모든 레퍼런스를 저장<br>- JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리 상 주소를 찾아 참조 | 위와 동일                                                                     | 모든 스레드 |
| Heap                                | - 프로그램에서 데이터를 저장하기 위해 런타임 시 **동적으로 할당하여 사용하는 메모리 영역**<br>                                                                               | - New 연산자를 통해 생성한 객체 또는 인스턴스, 배열 저장<br>- JVM이 관리                          | 모든 스레드 |
| Stack                               | - 메서드 정보, 지역변수, 매개변수, 연산 중 발생하는 **임시 데이터 저장**                                                                                           | - 선입후출(FILO)<br>- 메서드 호출, 종료 시 생성, 소멸 <br>- Frame 구조로 저장<br>- 메서드 끝날 때 삭제 | 각 스레드  |
| PC Register                         | - CPU instruction 수행 중 필요한 정보를 CPU 내 기억장치인 레지스터에 저장<br>- 연산 및 결과 값을 메모리에 전달하기 전 CPU 내 기억장치                                              | - **각 스레드 마다 현재 실행 중인 JVM 주소**를 가지고 있음<br>- CPU와는 별개로 JVM에서 관리한다.         | 각 스레드  |
| Native Method Stack                 | - 자바 외 언어로 작성된 네이티브 코드 저장                                                                                                               | - 자바 외부의 네이티브 호출 시 생성되고 완료시 소멸                                            | 각 스레드  |

https://chaewsscode.tistory.com/202

