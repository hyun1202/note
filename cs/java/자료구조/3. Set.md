## List vs Set
List
* 리스트는 요소들의 순차적인 컬렉션
* 중복을 허용한다.
* 인덱스를 통해 접근할 수 있다.
용도: 장바구니 목록, 순서가 중요한 일련의 이벤트 목록

Set
* 유일한 요소들의 컬렉션
* 이미 존재하는 요소면 무시된다
* 순서를 보장하지 않아 출력할 때 입력 순서와 다르다
* 요소의 유무를 빠르게 확인할 수 있다.
용도: 고유한 항목의 집합

해시 알고리즘
* 데이터를 찾는 검색 성능을 평균 O(1)로 끌어올릴 수 있다.

## 해시 알고리즘 - index 사용
배열은 인덱스의 위치를 사용해서 데이터를 찾을 때 O(1)인 특징이 있다.
그렇다면 데이터를 검색할 때도 인덱스를 활용하면 어떻게 될까?

인덱스와 데이터의 값은 서로 다르기 때문에 불가능하지만,
**데이터의 값 자체를 배열의 인덱스와 맞추어 저장**한다고 하면 가능하다.

### 한계 - 메모리 비효율
낭비되는 메모리 공간이 너무 많다.
99의 데이터라면 100 사이즈의 배열이 필요하다. (int의 모든 범위를 입력한다면 약 17기가바이트가 필요하다. )
int 범위: 약 42억 => 4byte * 42억

## 해시 알고리즘 - 나머지 연산
배열 크기에 맞추어 나머지 연산을 활용한다
나머지 연산의 결과는 절대로 배열의 크기를 넘지 않아 안전하게 인덱스로 사용할 수 있다.

### 한계 - 해시 충돌
1 % 10 = 1
11 % 10 = 1
다른 값을 입력했지만 같은 해시 코드가 나오는 경우가 있다.

해시 충돌은 낮은 확률로 일어난다.
1. 같은 해시 인덱스의 값을 같은 인덱스에 저장한다.
2. 해시 충돌이 난 경우 내부 데이터를 하나씩 비교해본다.

해시 충돌 최소화
1. 입력 값 개수보다 배열의 사이즈가 더 크면 충돌할 확률이 줄어든다.
2. 배열의 크기가 너무 큼 = 메모리 낭비, 너무 작음 = 잦은 해시 충돌
3. 통계상으로 입력 데이터 수가 배열의 크기의 75%를 넘지 않으면 충돌은 자주 발생하지 않는다.

## 해시 코드 - 문자
숫자 데이터가 아닌 문자 데이터를 해시 인덱스를 사용하고 싶다면?
아스키 코드를 만들어서 **해시코드**를 만든다

해시 코드: 데이터를 대표하는 값, 보통 해시 함수를 통해 만들어짐
해시인덱스: 
* 주로 해시 코드를 이용해서 만든다.
* 보통 코드의 결과에 배열의 크기를 나누어 구함

하지만 객체는 어떻게 해시 코드를 만들 수 있을까?

## 해시 코드 - 객체
`Object.hashCode()`: 
* 자신만의 해시 코드를 표현할 수 있는 기능
* 기본 구현은 **객체의 참조값을 기반**으로 해시 코드를 생성
	* 인스턴스가 다르면 해시 코드도 다르다.

### 동일성과 동등성
동일성: `==`연산자를 이용해서 두 객체의 **참조**가 동일한 객체를 가리키고 있는지 확인
동등성: `equals()` 메소드를 사용하여 두 객체가 **논리적으로 동등**한지 확인

객체를 해시 자료구조에 저장하기 위해 `hashCode()` 재정의가 필요하다.

`equals()`는 언제 사용할까?
`contains()`를 이용하여 객체의 동등성을 비교할 때 사용하게 된다.

그러므로 **해시 자료구조**를 이용하기 위해서는 ==`hashCode()`와 `equals()`의 재정의는 필수이다.==
### 해시 코드와 equals 모두 구현이 안되어 있을 경우
* 다른 위치에 데이터가 중복으로 저장된다.
* 데이터 검색이 불가능하다. (객체의 참조 값으로 해시코드가 생성됨)
### 해시코드만 구현 되어있을 경우
* **같은 위치**에 데이터가 중복으로 저장된다.
	* 해시 코드는 같아 index가 동일하지만 equals()가 재정의 되어있지 않아 다른 데이터로 인식
* 데이터 검색이 불가능하다. (데이터 비교 불가)
### equals만 구현 되어있을 경우
* 다른 위치에 데이터가 중복으로 저장된다.
* 데이터 검색이 불가능하다. (데이터 비교 불가)
## 정리
`set` 아이디어 
* 배열의 인덱스를 이용하면 더 빠른 속도로 검색, 삭제, 조회가 가능하다.
* **데이터와 인덱스를 동일**하게 하면 O(1)로 수행이 가능하다.
* 인덱스는 정수형이므로 문자나 객체는 정수형으로 변환이 필요하다.
	* 인덱스를 구하기 위해 해시 코드를 사용한다.
`hashCode()`: 해시 **인덱스를 설정**하기 위함
`equals()` 사용 목적
* 해시가 충돌될 경우 **데이터를 비교**하기 위함
	* 해시 인덱스가 같아도 실제 저장된 데이터가 다를 수 있다. -> 해시 충돌


데이터의 순서를 보장하지 않는 이유:
해시 인덱스를 이용하여 저장하기 때문에 순차적으로 저장이 되지 않는다.

# 컬렉션 프레임워크 HashSet
HashMap을 사용하여 구현한다.

HashSet
* 해시 코드를 이용하여 데이터와 인덱스를 동일하게 하여 중복 방지
* 인덱스가 순차적이지 않으므로 순서를 보장할 수 없다.
* 인덱스로 배열의 요소에 바로 접근이 가능하여 조회, 삭제, 검색의 성능이 해시 충돌이 없다면 O(1)이다.

LinkedHashSet
* HashSet에 연결 리스트를 추가해서 요소의 순서를 유지
* 연결 링크를 유지해야하므로 조금 무겁다 (양방향)
* 데이터를 입력한 순서대로 양방향으로 연결된다. (next, prev)

TreeSet
* 이진 탐색 트리를 개선한 레드 블랙트리를 내부에서 사용
* **정렬된 순서로 저장**됨
* 주요 연산은 O(log n), HashSet보다는 느림
* 범위 검색이나 정렬된 데이터가 필요한 경우 사용

이진 탐색 트리 계산의 핵심은 한번에 절반을 날린다. => O(log n)

최적화
데이터가 동적으로 계속 추가되므로 배열 크기의 75%를 넘으면 크기를 2배로 늘리고 늘어난 크기를 기준으로 해시 인덱스를 다시 적용한다.
HashSet의 기본 크기는 16이다.

만약 해시 충돌의 개수가 일정 개수 이상되면 (8 정도? 확실하지 않음)
Linked list를 TreeSet 자료구조로 변경한다. O(n) -> O(log n)