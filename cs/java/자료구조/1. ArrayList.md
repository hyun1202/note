# Array
첫번째 위치에 추가
* 배열의 첫번째 위치를 찾는데는 O(1)이 걸린다.
* 기존 데이터들을 모두 오른쪽으로 한 칸씩 밀어야 한다.
* O(1 + n) -> O(n)

중간 위치에 추가
* 배열의 첫번째 위치를 찾는데에는 O(1)이 걸린다.
* index 오른쪽의 데이터들은 모두 오른쪽으로 한 칸씩 밀어야 한다. (평균 n/2)
* O(1 + n/2) -> O(n)

배열의 마지막 위치에 추가
* 기존의 배열을 이동하지 않고, 배열의 길이를 사용하면 마지막 인덱스에 바로 접근이 가능하다.
* 기존 배열을 이동하지 않으므로 O(1)

배열의 한계
* 생성하는 시점에 배열의 크기를 미리 정해야한다.
	* 동적으로 길이를 늘릴 수가 없다.

# List
* 순서가 있고, 중복을 허용하는 자료 구조
* 크기가 동적으로 변할 수 있다.

# ArrayList
* 리스트의 자료구조를 사용하고 내부는 배열에 보관
## 특징
* 데이터 추가
	* 마지막: O(1)
	* 앞, 중간: O(n/2)
* 데이터 삭제
	* 마지막: O(1)
	* 앞, 중간: O(n)
* 인덱스 조회: O(1)
* 데이터 검색: O(n)

## 정리
* 데이터를 **중간에 추가하거나 삭제할 때 비효율적**이다.
	* 배열 리스트는 마지막에 데이터를 추가하거나 삭제하는 경우 O(1)로 매우 빠르지만, 중간에 데이터를 추가하거나 삭제하는 경우 O(n)으로 느리다.
* 정확한 배열 크기를 미리 알지 못하면 **메모리가 낭**비된다.
* 데이터를 **순서대로 입력하고 순서대로 출력하는 경우 가장 효율적**