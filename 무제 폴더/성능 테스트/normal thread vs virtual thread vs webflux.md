
## 데이터 조회(GET)
100명의 사용자가 10초동안 (딜레이X) 10건 이하의 데이터를 페이징 처리 없이 요청한 결과

normal:
![이미지](/이미지/thread/Pasted%20image%2020250312155229.png)

virtual thread:
![이미지](/이미지/thread/Pasted%20image%2020250312155331.png)

webflux:
![이미지](/이미지/thread/Pasted%20image%2020250312181905.png)


| 구분     | 처리    |
| ------ | ----- |
| 일반 스레드 | 52440 |
| 가상 스레드 | 30745 |
| 비동기    | 25721 |

---
## 데이터 삽입 (POST)
100명이 10초에 1번씩 데이터 삽입 (총 1000건)

normal:
![이미지](/이미지/thread/Pasted%20image%2020250312160042.png)

virtual thread:
![이미지](/이미지/thread/Pasted%20image%2020250312163006.png)

webflux:
![이미지](/이미지/thread/Pasted%20image%2020250312182837.png)

| 구분     | 처리   | 실패  |
| ------ | ---- | --- |
| 일반 스레드 | 100  | 49% |
| 가상 스레드 | 100  | 91% |
| 비동기    | 1000 | 0%  |


-------
### 2차 시도

#### GET
100명의 사용자가 10초동안 (딜레이X) **1000건의 데이터**를 페이징 처리 없이 요청한 결과

normal thread
![이미지](/이미지/thread/Pasted%20image%2020250312190850.png)

virtual thread
![이미지](/이미지/thread/Pasted%20image%2020250312191013.png)

webflux
![이미지](/이미지/thread/Pasted%20image%2020250312185722.png)

| 구분     | 처리   |
| ------ | ---- |
| 일반 스레드 | 8028 |
| 가상 스레드 | 7741 |
| 비동기    | 2698 |

-----


#### POST
normal
![이미지](/이미지/thread/Pasted%20image%2020250312185243.png)

virtual thread
![이미지](/이미지/thread/Pasted%20image%2020250312185502.png)

webflux
![이미지](/이미지/thread/Pasted%20image%2020250312185613.png)

| 구분     | 처리   | 실패  |
| ------ | ---- | --- |
| 일반 스레드 | 100  | 49% |
| 가상 스레드 | 100  | 49% |
| 비동기    | 1000 | 0%  |

## 결론
일반 스레드 vs 가상 스레드:
io 작업은 가상 스레드보다 일반 스레드가 성능이 더 좋다.

동기 vs 비동기
읽기의 경우 동기 방식이 더 성능이 좋았다.
쓰기의 경우 webflux가 **실패율 하나 없이 모든 요청을 처리**한 것을 확인

### 번외
webflux flux를 mono로 변경하여 모두 메모리에 올려서 테스트 한 get
![이미지](/이미지/thread/Pasted%20image%2020250312193139.png)
=> 그나마 flux 보다는 성능이 2.8배정도 향상되었으나 기존 동기 방식과는 약 1.8배?의 성능 차이가 난다
즉, **조회 성능은 훨씬 떨어진다.**

