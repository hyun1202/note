# 프로토콜 역사?
- 1900년도?
	- 소켓 프로그래밍...
	- 바이트 스트림 직접 처리..
	- 프로토콜 직접 설계!
		- 파싱, 엔디안, 에러처리 등 복잡하다.

- http
	- 매 요청마다 새로운 TCP 연결
	- 텍스트 프로토콜.... (바이트 제어X)
	- stateless, 각 요청마다 독립적인 요청
	- 통신에 있어 기본적인 오버헤드 증가 및 기본적으로 포함되는 중복된 데이터
		- 데이터가 큼..

- http 1.1
	- Keep-Alive로 연결 재사용 가능
	- chunked encoding을 통해 스트리밍 가능
		- Head of Line Blocking 여전히 존재
		- 앞에 있는 작업이나 데이터가 처리되지 않아 뒤에있는 작업들도 함께 지연

- http 2.0
	- **바이너리 프로토콜 사용**으로 파싱 속도가 빠름
	- **멀티 플렉싱** 기능을 사용하여 여러 스트림을 동시에 처리
	- HPACK을 통한 **헤더 압축**기능
	- 서버 푸시 기능 추가
		- 클라이언트가 요청하기 전 미리 보낼 수 있음

- MSA...
	- 서버간의 통신이 필요해짐
	- TCP 연결 오버헤드, json 파싱 오버헤드, HOLB, 타입 안정성 떨어짐, 스키마 진화 힘듦, 언어별 구현 불일치 등..으로 인해 gRPC가 나옴
	- 빠르면서 성능이 좋아야 함

- RPC??
	- 목표: 원격 함수를 로컬 함수처럼 호출한다. 
	- 네트워크에 대한 장애를 벗어나는 것이 목표
	- 동기 RPC
		- 직관적
		- 효율성이 떨어진다.
	- 비동기 RPC
		- 즉시 Future 구현
		- 리소스 효율성, 성능 높음
		- 복잡, 에러처리 어려움
		- 디버깅 어려움

# RPC vs gRPC?
- Apache Thrift
	- IDL 기반 RPC 선구자
	- 페이스북에서 개발
	- 인터페이스 정의 명확, 필수 선택 등 옵션 이런 필드 구분 가능, 예외처리, 직렬화 옵션 등
	- 스트리밍 형태 지원 불가 -> **실시간 데이터 처리 비효율**
	- http/2 버전 지원 불가 -> **성능 이슈**
- JSON-RPC
	- 요청, 응답 JSON 형식
	- 웹 개발자에게 친화적
	- Http post 기반
	- **성능 문제 (json 사용)**, 타입 안정성 문제(컴파일 환경에서 검증X)
	- **스트리밍 불가**
- gRPC
	- 핵심 목표
		- 실시간 통신 필요.
		- 성능 보장이 되어야 한다.
		- 안정성이 보장되어야 한다. -> 런타임 환경에서 검증X
		- 언어 자율성..
		- 확장성 (하위 호환성 보장)
	- stubby (2001)
		- 성능, 안정성 포기 불가해 구글에서 만든 프로토콜
		- 프로토콜 버퍼
		- 서비스 디스커버리 기능 내장
		- 통신 최적화
	- 2015년도 오픈소스화  -> gRPC 등장
	- **http/2 사용**
	- 언어 지원 확대
	- 클라우드 네이티브 -> 쿠버네티스/envoy 통합
	- 단점
		- 높은 러닝 커브, 웹에서 직접 호출이 안된다는 단점이 있음
	- 장점
		- http/2를 이용하여 데이터를 바이너리 형태로 처리
			- **프로토콜 버퍼**
		- 멀티플렉싱 기능으로 하나의 연결로 여러 요청을 동시에 처리 가능
		- 헤더 압축으로 데이터 크기가 줄음
		- TLS 기반의 보안 기본 지원
		- 양방향 스트리밍 기능 및 자동 플로우 컨트롤 기능 제공으로 실시간 데이터 송수신 및 서버 과부하 방지
		- 코드 자동 생성 기능
			- .proto 파일만 작성하고, 프로토콜 버퍼 컴파일러로 처리하면 클라이언트와 서버 코드 자동 생성
			- 언어 간의 일관성 보장

# JSON vs Protocol Buffers?
- json
	- 78 바이트
	- 텍스트 기반
	- 사람이 읽기 쉬움
		- 유지보수 측면에선 가장 좋다.
	- {}, "" 등 구조 문자를 모두 포함해야 하므로 데이터가 큼
- Protocol Buffers
	- 28 바이트
	- 필드 번호만 사용하여 기본적인 크기가 작음
		- 네트워크 비용 절감
	- 직렬화가 json 보다 7배 빠름, 60% 적은 메모리 사용
	- 서로 버전이 달라도 필드 번호를 이용하여 통신하므로, 해당 필드에 값이 없다면 무시함 (하위 호환성) -> **점진적인 업데이트 가능**


# Protocol Buffers
- **스키마 기반 설계**: 구조가 명확해야 시스템이 안정적이다.
	- 컴파일 타임 안전성: 개발 단계 오류 발견
	- 명시적 계약 정의: 명확한 인터페이스
	- 최적화된 성능: 필드 명 대신 필드 번호를 이용한 데이터 식별, 바이너리 인코딩으로 데이터 크기가 작음
	- 호환성 측면에서의 진화 가능한 설계: 스키마를 변경해도 하위 호환성을 기본적으로 보장
- 분산 시스템 직렬화 문제
	- 데이터 형식 딜레마: 텍스트는 읽기 쉽지만 느림, 바이너리는 빠르지만 읽기 어려움
	- 타입 시스템 딜레마: 강타입은 안전하지만 경직, 동적타입은 유연하지만 위험
	- 시스템 진화 딜레마: 하위 호환성을 유지하면 새 기능 추가 시 제약, 빠르게 진화한다면 기존 시스템과 충돌 가능
- 위 문제를 해결
	- JSON 대비 데이터 크기가 작음, 파싱 속도 빠름 -> 성능 좋음
	- 메모리 사용 효율적 -> 서버 부담 감소
- 단점
	- 디버깅 어려움 (직렬화된 데이터 확인 어려움)

# gRPC 통신 기법
## Unary RPC
- 가장 기본적인 통신 방식
- 통신 특징: http와 비슷
	- 동기식 처리: 1:1 통신 구조, 요청 - 응답 패턴
	- 상태 비 저장: 각 요청 독립적
	- 단순한 생명 주기: 요청 -> 처리 -> 응답 -> 종료
		-
- 데이터 조회
	- 캐싱 처리
	- 트랜잭션..
	- 에러처리 단순..

### 통신 과정
 1. 요청 준비 -> 프로토버퍼 바이너리로 직렬화
 2. 네트워크 전송 탭
	2.1 헤더 프레임 우선 전송
	2.2 데이터 프레임 전송
3. 서버에서 처리 과정 진행 -> 역직렬화 및 비지니스 로직 실행
4. 응답
	4.1 응답 헤더 전송
	4.2 데이터 프레임 전송

```
HTTP/2 HEADERS 프레임:
- :method: POST
- :path: /user.UserService/GetUser
- content-type: application/grpc+proto
- grpc-timeout: 30S
- authorization: Bearer [토큰]
  
HTTP/2 DATA 프레임:
- 압축 플래그: 0
- 메시지 길이: 5바이트
- 실제 데이터: protobuf 바이너리

-- 응답 --
HTTP/2 HEADERS 프레임:
- :status: 200
- content-type: application/grpc+proto
- grpc-encoding: gzip
  
HTTP/2 DATA 프레임:
- 압축 플래그: 1
- 메시지 길이: 42바이트
- 실제 데이터: 압축된 protobuf 바이너리
```

## 연결 관리
- 연결 풀에서 기존 연결을 확인
	- 없다면 새 연결 생성 후 풀에 저장
	-  있다면 연결 재 사용
-  연결 풀에서는 연결을 관리
	- 서비스별 구분
	- 유효성 점검
	- 최대 연결 수 제한
	- 자동 정리
- Keep-Alive 설정
	- ping 주기 및 간격 설정

## 배치 처리
- rest: 개별 요청 시 한 개씩 호출하면 100번의 호출이 필요
- 배치 크기 제한 필요 (100~1000)
- 부분 실패 처리 고려
- 장점
	- 전체 요청을 하나의 트랜잭션으로 묶어 처리할 수 있어 원자성 보장
	- 개별 요청마다 실패 여부를 검사할 필요 없이 배치 전체의 성공 여부만 전달
	- 배열로서 전달하여 통신 자원을 아낄 수 있음
- 단점
	- 여러 개 요청에 대해 하나라도 실패했을 때의 에러 핸들링..
- 배치 병렬 처리 시나리오
	1. 요청이 들어오면 요청 유효성 검증 (배치 크기 등)
	2. 워커풀을 기반으로 사용자 아이디를 개별 워커에 분배하여 병렬로 처리
	3. 워커들이 각자 데이터베이스 정보를 조회하고 그 결과를 수집하여 성공, 실패 항목으로 분류
	4. 분류된 데이터를 바탕으로 최종 응답 생성

# 스트리밍 RPC
- 백프레셔: 데이터의 생산 속도가 소비하는 속도보다 빠를 때 발생하는 문제 (컨슈머 렉, 처리량 밀림)
	- 버퍼링 전략: 속도 차이 흡수
	- 중요도 필터링
	- 적응적 배치: 네트워크 상황이나 클라이언트 처리 능력에 따른 동적 크기 조절
- 스트림 상태 추적
- 비활성 스트림 정리: 클라이언트 연결 종료(비정상 포함) 시 진행 중인 작업을 마무리 하고 안전하게 리소스 정리
- 핵심: 이벤트 스트림과 상태에 대한 동기화 과정?
	- Catch-up 기능: 특정 시점부터 재생
	- 느슨한 결합
	- 이벤트 필터링

```
syntax = "proto3"

service LogStreamService {
	rpc SteamLogs(stream Request) return (stream LogEntry)
}

message Request {
}

message LogEntry {
}
```

### 채널, 스텁
- 채널
	- gRPC에서 서버와의 네트워크 연결을 위한 객체
		- TCP 연결, TLS 암호화, HTTP/2 프로토콜 처리
	- 
- 스텁
	- 원격 서버의 메서드를 로컬 함수처럼 호출할 수 있게 해주는 클라이언트 객체

keep alive 핑
- 핑을 주기적으로 보내, 연결을 유지하고 빠른 장애 감지..
- keep alive 핑을 통해 트래픽이 많이 없어도 서버 정상 작동 유무도 확인 가능
- http tcp 기반의 Ping Kepp-Alive는 간격과 재시도 횟수를 설정하지만 HTTP/2 기반의 Ping은 타임아웃만 설정
- 너무 빠른 주기로 설정하게 되면 ddos 공격으로 의심될 수 있으므로, 1분 이상 간격으로 설정

### 채널 동시성 문제
- 채널 풀 사용..? (임시 방편)


양방향 플로우 컨트롤..
