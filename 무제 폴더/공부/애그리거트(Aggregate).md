# 애그리거트
- 데이터 변경의 목적을 위해 하나의 단위로 취급되는 연관된 객체들의 클러스터
- 루트(root)와 경계(boundary)를 가진다.
- 경계 내부에는 엔티티와 값 객체가 하나 또는 여러 개가 존재할 수 있다.
- 애그리거트 루트는 내부에 포함된 단일 엔티티이다.
## 특징
- 데이터 변경 시 하나의 단위로 취급
	- 데이터 변경의 일관성 유지
- 루트를 통한 접근 제어
	- 외부 객체는 루트 엔티티에만 참조를 가질 수 있다.
- 데이터 일관성 유지
	- 경계 내의 어떤 변경 사항이 있을 때 전체 애그리거트의 모든 불변식(invariant)이 충족되어야 한다.
	- 애그리거트를 넘어서는 불변식은 이벤트나 배치 등을 통해 특정 시간 내에 해결할 수 있다.
- 검색 및 접근 방식
	- 리포지토리를 통해 애그리거트 루트만 직접 얻을 수 있다.
	- 내부 엔티티는 루트로부터 연관관계를 통해서 접근한다.
- 생명주기 관리 캡슐화
	- Factory와 Repository를 이용해서 객체들을 생명주기에 걸쳐 체계적이고 의미있는 단위로 조작
## 목표
- 일관성 유지: 객체 그룹에 적용되는 불변식을 유지
- 이해 용이성: 객체의 시작과 끝을 명확히 해서 모델을 더 쉽게 이해
- 트랜잭션 및 동시성 관리: 트랜잭션 범위와 데이터 일관성 유지 방법 제공
- 모델 단순화: 연관 관계 탐색을 제한하고 루트를 통해서만 접근
## 적용 방법
- JPA의 cascading을 적절하게 활용한다.
- **리포지토리는 애그리거트 단위**로 만든다.
	- 스프링 데이터 JPA의 핵심 원칙
	- Repository<T, ID> : T = Aggregate Root
- 가능하다면 하나의 트랜잭션에 하나의 애그리거트만 변경한다. (권장)
	- 단, 하나의 애그리거트의 변경이 두개의 트랜잭션으로 쪼개지면 안된다.
- 다른 애그리거트의 참조는 애그리거트 루트에 대해서만 한다.
	- 연관관계 애그리거트 루트의 레퍼런스 대신 루트의 ID값만 저장하기도 한다.
### 적용의 어려움
- 적절한 애그리거트 경계를 선택하는 것은 꽤 어려운 결정이다.
- 개발하면서 애그리거트의 범위가 달라지기도 한다.
	- 대체로 작은 애그리거트가 될 가능성이 높다.
- 성능에 부담을 주게 된다. (lazy loading의 도움이 필요)
- 내부 엔티티로의 직접 접근이나 여러 애그리거트를 한번에 조회하는 기능이 필요한 경우가 있다.
- 도메인 이벤트와 최종적 일관성의 사용이 요구된다.
- 완벽한 애그리거트가 아니어도 괜찮다.

# 헥사고날 아키텍처와 애그리거트
- 애그리거트 단위로 애플리케이션(헥사곤)을 구성하는 방법이 유용하다.
- 다른 애그리거트로의 접근은 애플리케이션 **포트를 통해 ID를 전달**하는 방식으로
	- 애플리케이션 내부 리포지토리에서 루트 엔티티를 조회하는 방식으로 이루어지게 강제할 수 있다.
	- JPA는 ID가 있으면 캐시에서 꺼내온다..?
- 도메인 이벤트와 리스너를 이용해서 애그리거트 사이의 작업을 연결할 수도 있다.
	- 애그리거트를 설계하고 각각을 독립적인 애플리케이션으로 분리하자.