# 아키텍처에 따른 트랜잭션 처리
- 모놀리식 시스템: 단일 트렌잭션에서 모든 기능을 처리
- MSA 시스템: 
	- 한 코디네이터가 모든 참여자의 동의를 받아 트랜잭션을 커밋
	- 하나의 큰 비즈니스 트랜잭션을 작은 트랜잭션으로 분리, 실패한다면 보상 트랜잭션을 이용하여 되돌림



## 분산 트랜잭션이 필요한 이유
- 모놀리식 아키텍처에서는 모든 기능이 하나의 애플리케이션 안에 있음
	- 하나의 데이터베이스를 공유하는 패턴을 가지게 됨
	- 이러한 패턴은 ACID가 잘 보장되어있다.
- MSA 아키텍처에서는 각 서비스들이 독립적인 DB를 가지고 있을 수 있음
	- 각각 다른 트랜잭션이므로 공유가 되지 않는다. 
	- 주문 -> 재고 -> 결제 -> 배송으로 이루어진 MSA 서비스가 있다면,
		- 원자성 문제: 주문은 성공했으나 재고는 차감에 실패함
		- 일관성 문제: 결제는 성공했으나 배송 정보 생성에 실패한다면 데이터 불균형으로 인해 해야 하는 작업을 수행하지 못함
		- 격리성 문제: A가 주문을 했으나 결제에서 작업이 실패해 주문이 취소되는 사이 B가 재고를 조회한다면 잘못된 정보를 조회할 수 있음

## 분산 트랜잭션 관리 방법

### 1. 2PC (Two-Phase commit)
 - 분산 트랜잭션을 관리하는 전통적인 방법
 - 코디네이터라는 주체가 모든 참여자의 동의를 받아 트랜잭션을 커밋하는 구조
 - `Prepare` 와 `Commit` 의 단계가 있다.
 - `Prepare`: 모든 참여자가 커밋할 준비가 되어있는지 확인한다.
 - `Commit`: 커밋을 수행, 만약 커밋 도중 실패한 참여자가 있다면 모든 참여자에게 롤백을 수행하라는 명령을 보냄.
 - 모든 참여자가 락을 잡고 대기해야 한다는 단점이 있다.
 - 만약 코디네이터 서버가 비정상적이라면 모든 서비스가 무한정으로 블록킹이 될 수 있다.
 - 참여자가 많을 수록 성능이 낮아진다.

### 2.SAGA 패턴
- Dirty Read 발생 가능
	- 취소될 트랜잭션의 중간 상태를 읽을 수 있다.
- 잘못된 데이터를 일부 확인할 수 있으므로 이를 방지해야 한다.
- 방지법으로는 상태를 `예약` 상태로 두어 아직 완료되지 않은 트랜잭션은 보이지 않도록 하는 방법 등이 있다.
- BASE 모델을 따른다
	- Basically Available(기본 가용성)
	- Soft state(유연한 상태)
	- Eventually consistent(최종 일관성)
#### 핵심 특징
- 최종적 일관성
	- 일시적으로 불일치할 수 있으나 시간이 지나면 일관성 도달
- 보상을 통한 롤백
	- 비즈니스를 통한 논리적인 취소를 의미
		- 데이터베이스의 물리적인 롤백은 불가
- 분산된 제어
	- 중앙 조정자 방식(Orchestration)
	- 자율 분산 방식(Choreography)
#### 로컬 트랜잭션
- 각 서비스 내에서 독립적으로 실행되는 트랜잭션
#### 보상 트랜잭션
- 이미 커밋이 되었기 때문에 물리적인 롤백은 불가능
- 새로운 트랜잭션을 만들어 잘못된 케이스에 대한 효과를 상쇄한다
	- ex) 결제 환불 상태, 재고 복구, 주문 취소
- 완벽한 되돌림은 불가능
	- 이미 메일이 전송되었다면 취소하기는 힘들다. -> 메일을 재전송하는 것밖에 안됨
- 보상 트랜잭션과, 로컬 트랜잭션은 멱등하게 가진 설계가 필요하다.
	- 같은 결제 요청이 여러번 와도 한 번만 처리해야 한다.