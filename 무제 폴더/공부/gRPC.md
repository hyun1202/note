# 프로토콜 역사?
- 1900년도?
	- 소켓 프로그래밍...
	- 바이트 스트림 직접 처리..
	- 프로토콜 직접 설계!
		- 파싱, 엔디안, 에러처리 등 복잡하다.

- http
	- 매 요청마다 새로운 TCP 연결
	- 텍스트 프로토콜.... (바이트 제어X)
	- stateless, 각 요청마다 독립적인 요청
	- 통신에 있어 기본적인 오버헤드 증가 및 기본적으로 포함되는 중복된 데이터
		- 데이터가 큼..

- http 1.1
	- Keep-Alive로 연결 재사용 가능
	- chunked encoding을 통해 스트리밍 가능
		- Head of Line Blocking 여전히 존재
		- 앞에 있는 작업이나 데이터가 처리되지 않아 뒤에있는 작업들도 함께 지연

- http 2.0
	- **바이너리 프로토콜 사용**으로 파싱 속도가 빠름
	- **멀티 플렉싱** 기능을 사용하여 여러 스트림을 동시에 처리
	- HPACK을 통한 **헤더 압축**기능
	- 서버 푸시 기능 추가
		- 클라이언트가 요청하기 전 미리 보낼 수 있음

- MSA...
	- 서버간의 통신이 필요해짐
	- TCP 연결 오버헤드, json 파싱 오버헤드, HOLB, 타입 안정성 떨어짐, 스키마 진화 힘듦, 언어별 구현 불일치 등..으로 인해 gRPC가 나옴
	- 빠르면서 성능이 좋아야 함

- RPC??
	- 목표: 원격 함수를 로컬 함수처럼 호출한다. 
	- 네트워크에 대한 장애를 벗어나는 것이 목표
	- 동기 RPC
		- 직관적
		- 효율성이 떨어진다.
	- 비동기 RPC
		- 즉시 Future 구현
		- 리소스 효율성, 성능 높음
		- 복잡, 에러처리 어려움
		- 디버깅 어려움

# RPC vs gRPC?
- Apache Thrift
	- IDL 기반 RPC 선구자
	- 페이스북에서 개발
	- 인터페이스 정의 명확, 필수 선택 등 옵션 이런 필드 구분 가능, 예외처리, 직렬화 옵션 등
	- 스트리밍 형태 지원 불가 -> **실시간 데이터 처리 비효율**
	- http/2 버전 지원 불가 -> **성능 이슈**
- JSON-RPC
	- 요청, 응답 JSON 형식
	- 웹 개발자에게 친화적
	- Http post 기반
	- **성능 문제 (json 사용)**, 타입 안정성 문제(컴파일 환경에서 검증X)
	- **스트리밍 불가**
- gRPC
	- 핵심 목표
		- 실시간 통신 필요.
		- 성능 보장이 되어야 한다.
		- 안정성이 보장되어야 한다. -> 런타임 환경에서 검증X
		- 언어 자율성..
		- 확장성 (하위 호환성 보장)
	- stubby (2001)
		- 성능, 안정성 포기 불가해 구글에서 만든 프로토콜
		- 프로토콜 버퍼
		- 서비스 디스커버리 기능 내장
		- 통신 최적화
	- 2015년도 오픈소스화  -> gRPC 등장
	- **http/2 사용**
	- 언어 지원 확대
	- 클라우드 네이티브 -> 쿠버네티스/envoy 통합
	- 단점
		- 높은 러닝 커브, 웹에서 직접 호출이 안된다는 단점이 있음
	- 장점
		- http/2를 이용하여 데이터를 바이너리 형태로 처리
			- **프로토콜 버퍼**
		- 멀티플렉싱 기능으로 하나의 연결로 여러 요청을 동시에 처리 가능
		- 헤더 압축으로 데이터 크기가 줄음
		- TLS 기반의 보안 기본 지원
		- 양방향 스트리밍 기능 및 자동 플로우 컨트롤 기능 제공으로 실시간 데이터 송수신 및 서버 과부하 방지
		- 코드 자동 생성 기능
			- .proto 파일만 작성하고, 프로토콜 버퍼 컴파일러로 처리하면 클라이언트와 서버 코드 자동 생성
			- 언어 간의 일관성 보장

# JSON vs Protocol Buffers?
- json
	- 78 바이트
	- 텍스트 기반
	- 사람이 읽기 쉬움
		- 유지보수 측면에선 가장 좋다.
	- {}, "" 등 구조 문자를 모두 포함해야 하므로 데이터가 큼
- Protocol Buffers
	- 28 바이트
	- 필드 번호만 사용하여 기본적인 크기가 작음
		- 네트워크 비용 절감
	- 직렬화가 json 보다 7배 빠름, 60% 적은 메모리 사용
	- 서로 버전이 달라도 필드 번호를 이용하여 통신하므로, 해당 필드에 값이 없다면 무시함 (하위 호환성) -> **점진적인 업데이트 가능**


# Protocol Buffers
- **스키마 기반 설계**: 구조가 명확해야 시스템이 안정적이다.
	- 컴파일 타임 안전성: 개발 단계 오류 발견
	- 명시적 계약 정의: 명확한 인터페이스
	- 최적화된 성능: 필드 명 대신 필드 번호를 이용한 데이터 식별, 바이너리 인코딩으로 데이터 크기가 작음
	- 호환성 측면에서의 진화 가능한 설계: 스키마를 변경해도 하위 호환성을 기본적으로 보장
- 분산 시스템 직렬화 문제
	- 데이터 형식 딜레마: 텍스트는 읽기 쉽지만 느림, 바이너리는 빠르지만 읽기 어려움
	- 타입 시스템 딜레마: 강타입은 안전하지만 경직, 동적타입은 유연하지만 위험
	- 시스템 진화 딜레마: 하위 호환성을 유지하면 새 기능 추가 시 제약, 빠르게 진화한다면 기존 시스템과 충돌 가능
- 위 문제를 해결
	- JSON 대비 데이터 크기가 작음, 파싱 속도 빠름 -> 성능 좋음
	- 메모리 사용 효율적 -> 서버 부담 감소
- 단점
	- 디버깅 어려움 (직렬화된 데이터 확인 어려움)